#########################################################################
# SPECTRAL CLUSTERING ALGORITHM
# ==============================
# 
# Type of Algorithm:
# -------------------
# Un-normalized Laplacian: L = D - A
#
# DATASET:
# ---------
#
# Generated by the program. Data points are clustered into two circles -
# inner and outer ring using coordinate system.
#
# --------------------------------------------------------------------------
# The codes are based on Python2.7. 
# Please install numpy, scipy, matplotlib packages before using.
# Thank you for your suggestions!
#
# @version 1.0
# @author CSE6740/CS7641 TA
#########################################################################
import numpy as np
import matplotlib.pyplot as plt
import kmeans
from scipy.spatial.distance import pdist, squareform
import copy

## Data Generation 

# Generate random angles between [0, 2pi]
n = 800
rangle = 2 * np.pi * np.random.rand(n, 1)

# Generate random radius for the first circle;
e = 0.2
rr = 1.9 + e * np.random.rand(n, 1)

rx = rr * np.sin(rangle)
ry = rr * np.cos(rangle)

x = rx
y = ry

# Generate random radius for the second circle; 
rr2 = 1.2 + e * np.random.rand(n, 1)

rx2 = rr2 * np.sin(rangle)
ry2 = rr2 * np.cos(rangle)

x = np.concatenate((x, rx2), axis = 0)
y = np.concatenate((y, ry2), axis = 0)

# Generate points for inducing connectivity between two circles.
rx3 = 1.4 + (1.9 - 1.4) * np.random.rand(10, 1)
ry3 = e * np.random.rand(10, 1)

# uncomment this to comment the two rings; 
# x = np.concatenate((x, rx3), axis = 0)
# y = np.concatenate((y, ry3), axis = 0)

##
# Original data figure
data = np.concatenate((x, y), axis = 1)

plt.figure(1)
plt.plot(x, y, 'k.')
plt.hold(True)
plt.title('original data')

plt.show(block = False)
raw_input('press any key to continue ...')

# run kmeans on the original coordinates; 
K = 2
idx = kmeans.kmeans_python(data, K)

plt.figure(2)
plt.plot(x[idx == 0], y[idx == 0], 'r.')
plt.hold(True)
plt.plot(x[idx == 1], y[idx == 1], 'b.')
plt.title('K-means')

plt.show(block = False)
raw_input('press any key to continue ...')

# Distance between two points
distmat = np.power(squareform(pdist(data)), 2)

# Distance threshold to cluster points within distmat distance of each other
distmat[distmat == 1] = 2
distmat[distmat < 0.1] = 1
distmat[distmat != 1] = 0
np.fill_diagonal(distmat, 0)
A = copy.deepcopy(distmat)

## Spectral clustering Algorithm

D = np.diag(np.sum(A, 1)) # Step to go from adjacency matrix A to degree matrix D
L = D - A # unnormalized Laplacian

S, V = np.linalg.eig(L) # S contains eigenvalues for L and V is matrix whose 
                        # columns are the corresponding right eigenvectors
sortidx = S.argsort()                        
V = V[:,sortidx]      
                 
K = 2 # change cluster numbers here to experiment
idx = kmeans.kmeans_python(V[:,0:K], K)

# Cluster visualization for spectral algorithm
plt.figure(3)
plt.plot(x[idx == 0], y[idx == 0], 'r.')
plt.hold(True)
plt.plot(x[idx == 1], y[idx == 1], 'b.')
plt.title('Spectral Clustering')
plt.show()